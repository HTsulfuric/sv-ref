<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>sv-ref Hex Decoder</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

/* --- Dark theme (Slate) --- */
:root, :root[data-theme="dark"] {
  --bg-base: #0f1117;
  --bg-surface: #181a24;
  --bg-elevated: #1e2130;
  --bg-overlay: rgba(255,255,255,0.04);
  --border-primary: #2a2d3a;
  --border-subtle: #22242f;
  --text-primary: #e2e4ed;
  --text-secondary: #9196ab;
  --text-dim: #5c6178;
  --accent-primary: #6c8cff;
  --accent-secondary: #58d5a0;
  --accent-warn: #f0c060;
  --accent-error: #f06070;
  --hover-overlay: rgba(108,140,255,0.06);
  --register-bg: #141620;
  --register-border: #2a2d3a;
  --field-0: #f06070;
  --field-1: #f0a050;
  --field-2: #f0c060;
  --field-3: #58d5a0;
  --field-4: #6c8cff;
  --field-5: #b070f0;
  --field-6: #f090b0;
  --field-7: #40c8d0;
  --field-8: #90b0f0;
  --field-9: #c8a060;
  --field-0-bg: rgba(240,96,112,0.12);
  --field-1-bg: rgba(240,160,80,0.12);
  --field-2-bg: rgba(240,192,96,0.12);
  --field-3-bg: rgba(88,213,160,0.12);
  --field-4-bg: rgba(108,140,255,0.12);
  --field-5-bg: rgba(176,112,240,0.12);
  --field-6-bg: rgba(240,144,176,0.12);
  --field-7-bg: rgba(64,200,208,0.12);
  --field-8-bg: rgba(144,176,240,0.12);
  --field-9-bg: rgba(200,160,96,0.12);
  --shadow-sm: 0 1px 3px rgba(0,0,0,0.3);
  --shadow-md: 0 4px 12px rgba(0,0,0,0.4);
  --sidebar-width: 280px;
}

/* --- Light theme (Paper) --- */
:root[data-theme="light"] {
  --bg-base: #f8f9fc;
  --bg-surface: #ffffff;
  --bg-elevated: #f0f1f5;
  --bg-overlay: rgba(0,0,0,0.03);
  --border-primary: #dde0e8;
  --border-subtle: #eceef3;
  --text-primary: #1a1d2e;
  --text-secondary: #5c6178;
  --text-dim: #9196ab;
  --accent-primary: #3b5ccc;
  --accent-secondary: #1a9660;
  --accent-warn: #b08020;
  --accent-error: #c83040;
  --hover-overlay: rgba(59,92,204,0.05);
  --register-bg: #f4f5f8;
  --register-border: #dde0e8;
  --field-0: #c83040;
  --field-1: #c07020;
  --field-2: #a08010;
  --field-3: #1a9660;
  --field-4: #3b5ccc;
  --field-5: #7840c0;
  --field-6: #c05080;
  --field-7: #1098a0;
  --field-8: #4070c0;
  --field-9: #987030;
  --field-0-bg: rgba(200,48,64,0.08);
  --field-1-bg: rgba(192,112,32,0.08);
  --field-2-bg: rgba(160,128,16,0.08);
  --field-3-bg: rgba(26,150,96,0.08);
  --field-4-bg: rgba(59,92,204,0.08);
  --field-5-bg: rgba(120,64,192,0.08);
  --field-6-bg: rgba(192,80,128,0.08);
  --field-7-bg: rgba(16,152,160,0.08);
  --field-8-bg: rgba(64,112,192,0.08);
  --field-9-bg: rgba(152,112,48,0.08);
  --shadow-sm: 0 1px 3px rgba(0,0,0,0.08);
  --shadow-md: 0 4px 12px rgba(0,0,0,0.1);
}

/* --- Typography --- */
body {
  font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  font-size: 14px;
  background: var(--bg-base);
  color: var(--text-primary);
  height: 100vh;
  display: grid;
  grid-template-columns: var(--sidebar-width) 1fr;
  overflow: hidden;
  transition: grid-template-columns 0.25s ease;
  -webkit-font-smoothing: antialiased;
}

body.sidebar-collapsed {
  grid-template-columns: 48px 1fr;
}

.mono {
  font-family: "JetBrains Mono", "SF Mono", "Cascadia Code", "Fira Code", Consolas, monospace;
}

/* --- Sidebar --- */
.sidebar {
  background: var(--bg-surface);
  border-right: 1px solid var(--border-primary);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  position: relative;
  min-width: 0;
}

.sidebar-collapsed .sidebar { overflow: visible; }

.sidebar-header {
  padding: 14px 16px;
  border-bottom: 1px solid var(--border-primary);
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  min-height: 56px;
}

.sidebar-collapsed .sidebar-header {
  padding: 14px 8px;
  justify-content: center;
}

.sidebar-brand {
  display: flex;
  flex-direction: column;
  min-width: 0;
}

.sidebar-collapsed .sidebar-brand { display: none; }

.sidebar-title {
  font-size: 15px;
  font-weight: 700;
  color: var(--accent-primary);
  letter-spacing: -0.3px;
}

.sidebar-title small {
  display: block;
  font-size: 11px;
  font-weight: 400;
  color: var(--text-dim);
  margin-top: 1px;
}

.sidebar-controls {
  display: flex;
  align-items: center;
  gap: 6px;
  flex-shrink: 0;
}

.sidebar-collapsed .sidebar-controls { flex-direction: column; }

.btn-icon {
  background: none;
  border: 1px solid var(--border-primary);
  color: var(--text-secondary);
  width: 30px;
  height: 30px;
  border-radius: 6px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 13px;
  transition: background 0.15s, color 0.15s, border-color 0.15s;
}

.btn-icon:hover {
  background: var(--hover-overlay);
  color: var(--text-primary);
  border-color: var(--accent-primary);
}

.sidebar-search {
  padding: 8px 10px;
  border-bottom: 1px solid var(--border-primary);
}

.sidebar-collapsed .sidebar-search { display: none; }

.search-input {
  width: 100%;
  padding: 7px 10px;
  background: var(--bg-base);
  border: 1px solid var(--border-primary);
  border-radius: 6px;
  color: var(--text-primary);
  font-family: inherit;
  font-size: 13px;
  outline: none;
  transition: border-color 0.15s, box-shadow 0.15s;
}

.search-input:focus {
  border-color: var(--accent-primary);
  box-shadow: 0 0 0 2px rgba(108,140,255,0.15);
}

.search-input::placeholder { color: var(--text-dim); }

.type-list {
  flex: 1;
  overflow-y: auto;
  padding: 6px;
}

.sidebar-collapsed .type-list { display: none; }

/* Package groups */
.pkg-header {
  padding: 6px 10px;
  font-size: 11px;
  font-weight: 600;
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 6px;
  user-select: none;
  margin-top: 6px;
  border-radius: 4px;
  transition: color 0.15s;
}

.pkg-header:first-child { margin-top: 0; }
.pkg-header:hover { color: var(--text-secondary); }

.pkg-header::before {
  content: "";
  display: inline-block;
  width: 0;
  height: 0;
  border-left: 5px solid currentColor;
  border-top: 4px solid transparent;
  border-bottom: 4px solid transparent;
  transition: transform 0.15s;
  flex-shrink: 0;
}

.pkg-group:not(.collapsed) .pkg-header::before {
  transform: rotate(90deg);
}

.pkg-group.collapsed .type-item { display: none; }

.pkg-count {
  margin-left: auto;
  font-size: 10px;
  opacity: 0.6;
}

.type-item {
  padding: 7px 10px;
  cursor: pointer;
  border-radius: 6px;
  margin-bottom: 1px;
  display: flex;
  align-items: center;
  gap: 8px;
  transition: background 0.12s;
}

.type-item:hover { background: var(--hover-overlay); }
.type-item.active {
  background: var(--accent-primary);
  color: #fff;
}

.type-item.kbd-highlight {
  outline: 2px solid var(--accent-primary);
  outline-offset: -2px;
}

.type-badge {
  font-family: "JetBrains Mono", monospace;
  font-size: 10px;
  padding: 2px 6px;
  border-radius: 4px;
  font-weight: 600;
  text-transform: uppercase;
  flex-shrink: 0;
}

.type-badge.struct { background: rgba(108,140,255,0.15); color: var(--accent-primary); }
.type-badge.enum { background: rgba(88,213,160,0.15); color: var(--accent-secondary); }
.type-item.active .type-badge { background: rgba(255,255,255,0.2); color: inherit; }

.type-name {
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  font-size: 13px;
  font-weight: 500;
}

.type-width {
  font-family: "JetBrains Mono", monospace;
  font-size: 11px;
  color: var(--text-dim);
  flex-shrink: 0;
}

.type-item.active .type-width { color: inherit; opacity: 0.7; }

.sidebar-footer {
  padding: 10px 14px;
  border-top: 1px solid var(--border-primary);
  font-size: 11px;
  color: var(--text-dim);
  line-height: 1.6;
}

.sidebar-collapsed .sidebar-footer { display: none; }

.sidebar-footer kbd {
  display: inline-block;
  font-family: "JetBrains Mono", monospace;
  font-size: 10px;
  padding: 1px 5px;
  background: var(--bg-base);
  border: 1px solid var(--border-primary);
  border-radius: 3px;
  min-width: 18px;
  text-align: center;
}

/* --- Main area --- */
.main {
  display: flex;
  flex-direction: column;
  overflow: hidden;
  min-width: 0;
}

.toolbar {
  padding: 14px 24px;
  border-bottom: 1px solid var(--border-primary);
  display: flex;
  align-items: center;
  gap: 16px;
  flex-wrap: wrap;
  background: var(--bg-surface);
}

.toolbar-left {
  display: flex;
  flex-direction: column;
  gap: 2px;
  min-width: 0;
}

.toolbar-right {
  margin-left: auto;
  display: flex;
  align-items: center;
  gap: 10px;
  flex-shrink: 0;
}

.toolbar label {
  font-size: 11px;
  color: var(--text-dim);
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.hex-input {
  font-family: "JetBrains Mono", monospace;
  font-size: 16px;
  padding: 8px 14px;
  background: var(--bg-base);
  border: 1px solid var(--border-primary);
  border-radius: 6px;
  color: var(--text-primary);
  width: 280px;
  outline: none;
  transition: border-color 0.15s, box-shadow 0.15s;
}

.hex-input:focus {
  border-color: var(--accent-primary);
  box-shadow: 0 0 0 2px rgba(108,140,255,0.15);
}

.hex-input::placeholder { color: var(--text-dim); }

.type-title {
  font-size: 17px;
  font-weight: 700;
  color: var(--text-primary);
  letter-spacing: -0.3px;
}

.type-info {
  font-family: "JetBrains Mono", monospace;
  font-size: 12px;
  color: var(--text-secondary);
}

.content {
  flex: 1;
  overflow-y: auto;
  padding: 24px;
}

/* --- Empty state --- */
.empty-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  gap: 20px;
  color: var(--text-dim);
  text-align: center;
  padding: 40px;
}

.empty-state-title {
  font-size: 18px;
  font-weight: 600;
  color: var(--text-secondary);
}

.empty-state-subtitle {
  font-size: 14px;
  max-width: 400px;
  line-height: 1.5;
}

.empty-state-shortcuts {
  display: grid;
  grid-template-columns: auto 1fr;
  gap: 6px 14px;
  font-size: 12px;
  text-align: left;
  margin-top: 8px;
}

.empty-state-shortcuts kbd {
  font-family: "JetBrains Mono", monospace;
  font-size: 10px;
  padding: 2px 6px;
  background: var(--bg-surface);
  border: 1px solid var(--border-primary);
  border-radius: 3px;
  text-align: center;
}

.empty-state-count {
  font-family: "JetBrains Mono", monospace;
  font-size: 12px;
  color: var(--accent-primary);
  margin-top: 4px;
}

/* --- Register map --- */
.register-map {
  margin-bottom: 24px;
  border: 1px solid var(--register-border);
  border-radius: 8px;
  background: var(--register-bg);
  padding: 16px;
  overflow-x: auto;
}

.register-row {
  margin-bottom: 12px;
}

.register-row:last-child { margin-bottom: 0; }

.bit-ruler {
  display: grid;
  gap: 1px;
  margin-bottom: 3px;
  min-width: fit-content;
}

.bit-ruler span {
  font-family: "JetBrains Mono", monospace;
  font-size: 9px;
  color: var(--text-dim);
  text-align: center;
  line-height: 1;
  user-select: none;
}

.reg-fields {
  display: grid;
  gap: 1px;
  min-width: fit-content;
}

.reg-field {
  padding: 6px 4px;
  text-align: center;
  font-size: 11px;
  font-weight: 600;
  border-radius: 3px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  cursor: default;
  transition: transform 0.1s, box-shadow 0.1s;
  position: relative;
  min-height: 32px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 1px;
}

.reg-field:hover {
  transform: translateY(-1px);
  box-shadow: var(--shadow-md);
  z-index: 1;
}

.reg-field-name {
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 100%;
  font-size: 11px;
}

.reg-field-value {
  font-family: "JetBrains Mono", monospace;
  font-size: 9px;
  opacity: 0.75;
}

.reg-field-bits {
  font-family: "JetBrains Mono", monospace;
  font-size: 8px;
  opacity: 0.6;
}

.reg-field.hovered {
  transform: translateY(-1px);
  box-shadow: var(--shadow-md);
  z-index: 1;
}

/* --- Field detail table --- */
.fields-section {
  margin-top: 16px;
}

.fields-section h3 {
  font-size: 12px;
  font-weight: 600;
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 10px;
}

.fields-table {
  width: 100%;
  border-collapse: collapse;
}

.fields-table th {
  font-size: 11px;
  font-weight: 600;
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 0.3px;
  text-align: left;
  padding: 8px 12px;
  border-bottom: 1px solid var(--border-primary);
}

.fields-table td {
  padding: 8px 12px;
  font-size: 13px;
  border-bottom: 1px solid var(--border-subtle);
  vertical-align: middle;
}

.fields-table tr:last-child td { border-bottom: none; }

.fields-table tr:hover { background: var(--hover-overlay); }

.fields-table tr.field-highlighted {
  background: var(--hover-overlay);
}

.field-color-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  display: inline-block;
  flex-shrink: 0;
}

.field-name-cell {
  font-weight: 600;
}

.field-type-name {
  font-family: "JetBrains Mono", monospace;
  font-size: 11px;
  color: var(--text-secondary);
  font-weight: 400;
}

.field-bits-cell {
  font-family: "JetBrains Mono", monospace;
  font-size: 12px;
  color: var(--text-secondary);
}

.field-hex-cell {
  font-family: "JetBrains Mono", monospace;
  color: var(--accent-primary);
  word-break: break-all;
}

.field-decoded-cell {
  font-family: "JetBrains Mono", monospace;
  color: var(--accent-secondary);
  word-break: break-all;
}

.field-row-nested td {
  padding-left: 32px;
  opacity: 0.85;
  font-size: 12px;
}

.field-row-nested .field-name-cell::before {
  content: "| ";
  color: var(--text-dim);
  font-weight: 400;
}

/* --- Enum table --- */
.enum-section { margin-top: 16px; }

.enum-section h3 {
  font-size: 12px;
  font-weight: 600;
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 10px;
}

.enum-table {
  width: 100%;
  border-collapse: collapse;
}

.enum-table th {
  font-size: 11px;
  font-weight: 600;
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 0.3px;
  text-align: left;
  padding: 8px 12px;
  border-bottom: 1px solid var(--border-primary);
}

.enum-table td {
  padding: 8px 12px;
  font-size: 13px;
  border-bottom: 1px solid var(--border-subtle);
  vertical-align: middle;
}

.enum-table tr:last-child td { border-bottom: none; }
.enum-table tr:hover { background: var(--hover-overlay); }

.enum-name { font-weight: 600; }

.enum-value {
  font-family: "JetBrains Mono", monospace;
  color: var(--accent-primary);
}

.enum-hex {
  font-family: "JetBrains Mono", monospace;
  color: var(--text-secondary);
}

.enum-match {
  border-left: 3px solid var(--accent-secondary);
  background: rgba(88,213,160,0.06);
}

.enum-match .enum-name {
  color: var(--accent-secondary);
}

.enum-result {
  margin-top: 14px;
  font-size: 14px;
  padding: 10px 14px;
  border-radius: 6px;
  background: var(--bg-surface);
  border: 1px solid var(--border-primary);
}

.enum-result strong {
  color: var(--accent-secondary);
}

.enum-result.no-match {
  color: var(--accent-warn);
  border-color: rgba(240,192,96,0.3);
}

/* --- Status & messages --- */
.hex-status {
  font-family: "JetBrains Mono", monospace;
  font-size: 11px;
  font-weight: 600;
  padding: 4px 8px;
  border-radius: 4px;
  white-space: nowrap;
  min-width: 48px;
  text-align: center;
}

.hex-status.exact { background: rgba(88,213,160,0.15); color: var(--accent-secondary); }
.hex-status.padded { background: rgba(240,192,96,0.15); color: var(--accent-warn); }
.hex-status.overflow { background: rgba(240,96,112,0.15); color: var(--accent-error); }

.error-msg {
  color: var(--accent-error);
  font-size: 13px;
  margin-top: 8px;
  padding: 10px 14px;
  border-radius: 6px;
  background: rgba(240,96,112,0.06);
  border: 1px solid rgba(240,96,112,0.15);
}

/* --- Copy to clipboard --- */
.copyable {
  cursor: pointer;
  border-radius: 3px;
  padding: 1px 3px;
  margin: -1px -3px;
  transition: background 0.15s;
}

.copyable:hover { background: var(--bg-overlay); }

.copied {
  background: var(--accent-secondary) !important;
  color: #fff !important;
  transition: none;
}

/* --- Animations --- */
@keyframes fadeSlideIn {
  from {
    opacity: 0;
    transform: translateY(8px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.content-animate {
  animation: fadeSlideIn 0.2s ease-out;
}

@keyframes valuePulse {
  0% { background-color: rgba(108,140,255,0.2); }
  100% { background-color: transparent; }
}

.value-pulse {
  animation: valuePulse 0.4s ease-out;
}

/* --- Scrollbar --- */
::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: var(--border-primary); border-radius: 3px; }
::-webkit-scrollbar-thumb:hover { background: var(--text-dim); }

/* --- Responsive --- */
@media (max-width: 768px) {
  body { grid-template-columns: 1fr; }
  .sidebar { display: none; }
}
</style>
</head>
<body>

<div class="sidebar">
  <div class="sidebar-header">
    <div class="sidebar-brand">
      <div class="sidebar-title">
        sv-ref
        <small id="meta-info"></small>
      </div>
    </div>
    <div class="sidebar-controls">
      <button class="btn-icon" id="theme-toggle" title="Toggle theme (T)">T</button>
      <button class="btn-icon" id="sidebar-collapse" title="Collapse sidebar">&#171;</button>
    </div>
  </div>
  <div class="sidebar-search">
    <input type="text" class="search-input" id="search-input" placeholder="Search types... (/)">
  </div>
  <div class="type-list" id="type-list"></div>
  <div class="sidebar-footer">
    <kbd>/</kbd> Search &nbsp; <kbd>&#8593;&#8595;</kbd> Navigate &nbsp; <kbd>Enter</kbd> Select<br>
    <kbd>Esc</kbd> Clear &nbsp; <kbd>T</kbd> Theme
  </div>
</div>

<div class="main">
  <div class="toolbar" id="toolbar" style="display:none;">
    <div class="toolbar-left">
      <div class="type-title" id="type-title"></div>
      <div class="type-info" id="type-info"></div>
    </div>
    <div class="toolbar-right">
      <label for="hex-input">Hex</label>
      <input type="text" class="hex-input" id="hex-input" placeholder="e.g. DEAD">
      <span class="hex-status" id="hex-status"></span>
    </div>
  </div>
  <div class="content" id="content">
    <div class="empty-state" id="empty-state"></div>
  </div>
</div>

<script type="application/json" id="refbook-data">
{{ refbook_json }}
</script>

<script>
(function() {
  "use strict";

  // --- Helpers ---

  function escHtml(s) {
    if (!s) return "";
    return String(s).replace(/&/g, "&amp;").replace(/</g, "&lt;")
      .replace(/>/g, "&gt;").replace(/"/g, "&quot;");
  }

  function escAttr(s) {
    return String(s).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/</g, "&lt;");
  }

  function binToBigInt(b) { return BigInt("0b" + b); }

  function bigIntToHex(val, hexLen) {
    var h = val.toString(16).toUpperCase();
    while (h.length < hexLen) h = "0" + h;
    return "0x" + h;
  }

  function hexToBin(hex) {
    var bin = "";
    for (var i = 0; i < hex.length; i++) {
      bin += ("0000" + parseInt(hex[i], 16).toString(2)).slice(-4);
    }
    return bin;
  }

  function extractBits(bits, offset, width) {
    if (!bits) return null;
    var msb = bits.length - 1 - offset;
    var start = msb - width + 1;
    if (start < 0) start = 0;
    return bits.slice(start, msb + 1);
  }

  function bitsToHex(b) {
    if (!b || b.length === 0) return "";
    var val = binToBigInt(b);
    var hexLen = Math.ceil(b.length / 4);
    return bigIntToHex(val, hexLen);
  }

  function findEnumName(members, bits) {
    if (!members || !bits) return null;
    var val = binToBigInt(bits);
    for (var i = 0; i < members.length; i++) {
      if (BigInt(members[i].value) === val) return members[i].name;
    }
    return null;
  }

  function getFieldColor(idx) {
    return "var(--field-" + (idx % 10) + ")";
  }

  function getFieldBg(idx) {
    return "var(--field-" + (idx % 10) + "-bg)";
  }

  // --- Theme ---

  function initTheme() {
    var saved = localStorage.getItem("sv-ref-theme") || "dark";
    document.documentElement.dataset.theme = saved;
    updateThemeButton();
  }

  function toggleTheme() {
    var current = document.documentElement.dataset.theme;
    var next = current === "dark" ? "light" : "dark";
    document.documentElement.dataset.theme = next;
    localStorage.setItem("sv-ref-theme", next);
    updateThemeButton();
    decode();
  }

  function updateThemeButton() {
    var btn = document.getElementById("theme-toggle");
    btn.textContent = document.documentElement.dataset.theme === "dark" ? "L" : "D";
    btn.title = "Toggle theme (T) - currently " + document.documentElement.dataset.theme;
  }

  initTheme();

  // --- Sidebar collapse ---

  var sidebarCollapsed = localStorage.getItem("sv-ref-sidebar") === "collapsed";

  function applySidebarState() {
    document.body.classList.toggle("sidebar-collapsed", sidebarCollapsed);
    var btn = document.getElementById("sidebar-collapse");
    btn.innerHTML = sidebarCollapsed ? "&#187;" : "&#171;";
  }

  function toggleSidebar() {
    sidebarCollapsed = !sidebarCollapsed;
    localStorage.setItem("sv-ref-sidebar", sidebarCollapsed ? "collapsed" : "expanded");
    applySidebarState();
  }

  applySidebarState();
  document.getElementById("sidebar-collapse").addEventListener("click", toggleSidebar);
  document.getElementById("theme-toggle").addEventListener("click", toggleTheme);

  // --- Data ---

  var refbook = JSON.parse(document.getElementById("refbook-data").textContent);
  var selectedType = null;

  var metaEl = document.getElementById("meta-info");
  metaEl.textContent = "v" + refbook.meta.version + " | " +
    refbook.meta.source_files.length + " file(s)";

  // --- Empty state ---

  function renderEmptyState() {
    var el = document.getElementById("empty-state");
    if (!el) return;
    var structCount = 0;
    var enumCount = 0;
    refbook.types.forEach(function(t) {
      if (t.kind === "struct") structCount++;
      else enumCount++;
    });
    el.innerHTML =
      '<div class="empty-state-title">Select a type to inspect</div>' +
      '<div class="empty-state-subtitle">Choose a struct or enum from the sidebar to view its register map and decode hex values.</div>' +
      '<div class="empty-state-count">' + structCount + ' structs, ' + enumCount + ' enums loaded</div>' +
      '<div class="empty-state-shortcuts">' +
      '<kbd>/</kbd><span>Focus search</span>' +
      '<kbd>&#8593; &#8595;</kbd><span>Navigate types</span>' +
      '<kbd>Enter</kbd><span>Select type</span>' +
      '<kbd>T</kbd><span>Toggle theme</span>' +
      '<kbd>Esc</kbd><span>Clear search</span>' +
      '</div>';
  }

  renderEmptyState();

  // --- Build sidebar ---

  var listEl = document.getElementById("type-list");
  var searchInput = document.getElementById("search-input");
  var hexInput = document.getElementById("hex-input");

  var packages = {};
  var pkgOrder = [];
  refbook.types.forEach(function(t, idx) {
    var pkg = t.package || "(no package)";
    if (!packages[pkg]) {
      packages[pkg] = [];
      pkgOrder.push(pkg);
    }
    packages[pkg].push({ type: t, index: idx });
  });

  pkgOrder.forEach(function(pkg) {
    var group = document.createElement("div");
    group.className = "pkg-group collapsed";

    var header = document.createElement("div");
    header.className = "pkg-header";

    var headerName = document.createElement("span");
    headerName.textContent = pkg;
    header.appendChild(headerName);

    var count = document.createElement("span");
    count.className = "pkg-count";
    count.textContent = packages[pkg].length;
    header.appendChild(count);

    header.addEventListener("click", function() {
      group.classList.toggle("collapsed");
    });
    group.appendChild(header);

    packages[pkg].forEach(function(entry) {
      var t = entry.type;
      var idx = entry.index;

      var item = document.createElement("div");
      item.className = "type-item";
      item.dataset.index = idx;
      item.dataset.name = t.name;
      item.dataset.package = pkg;

      var badge = document.createElement("span");
      badge.className = "type-badge " + t.kind;
      badge.textContent = t.kind === "struct" ? "S" : "E";

      var name = document.createElement("span");
      name.className = "type-name";
      name.textContent = t.name;

      var width = document.createElement("span");
      width.className = "type-width";
      width.textContent = t.total_width + "b";

      item.appendChild(badge);
      item.appendChild(name);
      item.appendChild(width);
      item.addEventListener("click", function() { selectType(idx); });
      group.appendChild(item);
    });

    listEl.appendChild(group);
  });

  // --- Sidebar search ---

  searchInput.addEventListener("input", function() {
    filterTypes(searchInput.value);
    activeNavIndex = -1;
    clearKbdHighlight();
  });

  function filterTypes(query) {
    query = query.trim().toLowerCase();
    var isSearching = query.length > 0;

    var groups = listEl.querySelectorAll(".pkg-group");
    for (var g = 0; g < groups.length; g++) {
      var group = groups[g];
      var items = group.querySelectorAll(".type-item");
      var anyVisible = false;

      for (var i = 0; i < items.length; i++) {
        var item = items[i];
        if (isSearching) {
          var tName = (item.dataset.name || "").toLowerCase();
          var tPkg = (item.dataset.package || "").toLowerCase();
          var match = tName.indexOf(query) !== -1 || tPkg.indexOf(query) !== -1;
          item.style.display = match ? "flex" : "none";
          if (match) anyVisible = true;
        } else {
          item.style.display = "";
          anyVisible = true;
        }
      }

      group.style.display = (isSearching && !anyVisible) ? "none" : "";
    }
  }

  // --- Keyboard navigation ---

  var activeNavIndex = -1;

  function getVisibleItems() {
    var all = listEl.querySelectorAll(".type-item");
    var visible = [];
    for (var i = 0; i < all.length; i++) {
      if (all[i].offsetParent !== null && all[i].style.display !== "none") {
        visible.push(all[i]);
      }
    }
    return visible;
  }

  function clearKbdHighlight() {
    var items = listEl.querySelectorAll(".kbd-highlight");
    for (var i = 0; i < items.length; i++) {
      items[i].classList.remove("kbd-highlight");
    }
  }

  function highlightNavItem(visible, index) {
    clearKbdHighlight();
    if (index >= 0 && index < visible.length) {
      visible[index].classList.add("kbd-highlight");
      visible[index].scrollIntoView({ block: "nearest" });
    }
  }

  document.addEventListener("keydown", function(e) {
    // Theme toggle
    if (e.key === "t" || e.key === "T") {
      if (document.activeElement !== searchInput && document.activeElement !== hexInput) {
        e.preventDefault();
        toggleTheme();
        return;
      }
    }

    if (e.key === "/" && document.activeElement !== searchInput && document.activeElement !== hexInput) {
      e.preventDefault();
      searchInput.focus();
      return;
    }

    if (e.key === "Escape") {
      if (searchInput.value) {
        searchInput.value = "";
        filterTypes("");
      }
      searchInput.blur();
      hexInput.blur();
      activeNavIndex = -1;
      clearKbdHighlight();
      return;
    }

    if (e.key === "ArrowDown" || e.key === "ArrowUp") {
      e.preventDefault();
      var visible = getVisibleItems();
      if (visible.length === 0) return;

      if (e.key === "ArrowDown") {
        activeNavIndex = Math.min(activeNavIndex + 1, visible.length - 1);
      } else {
        activeNavIndex = Math.max(activeNavIndex - 1, 0);
      }

      highlightNavItem(visible, activeNavIndex);
      return;
    }

    if (e.key === "Enter" && activeNavIndex >= 0) {
      var visible = getVisibleItems();
      if (activeNavIndex < visible.length) {
        var idx = parseInt(visible[activeNavIndex].dataset.index);
        selectType(idx);
        hexInput.focus();
        activeNavIndex = -1;
        clearKbdHighlight();
      }
      return;
    }
  });

  // --- Hex input ---

  hexInput.addEventListener("input", function() { decode(); });

  // --- Select type ---

  function selectType(idx) {
    selectedType = refbook.types[idx];

    var items = listEl.querySelectorAll(".type-item");
    for (var i = 0; i < items.length; i++) {
      var isActive = parseInt(items[i].dataset.index) === idx;
      items[i].classList.toggle("active", isActive);
      if (isActive) {
        var parentGroup = items[i].closest(".pkg-group");
        if (parentGroup) parentGroup.classList.remove("collapsed");
      }
    }

    document.getElementById("toolbar").style.display = "flex";
    document.getElementById("type-title").textContent = selectedType.name;

    var pkg = selectedType.package ? selectedType.package + "::" : "";
    document.getElementById("type-info").textContent =
      pkg + selectedType.name + " [" + selectedType.total_width + " bits]";

    hexInput.value = "";
    var maxHex = Math.ceil(selectedType.total_width / 4);
    hexInput.placeholder = maxHex + " hex chars (" + selectedType.total_width + " bits)";
    updateHexStatus("");
    decode();
  }

  // --- URL hash routing ---

  function updateHash() {
    if (!selectedType) return;
    var hash = "#type=" + encodeURIComponent(selectedType.name);
    var hex = hexInput.value.replace(/[\s_]/g, "");
    if (hex) hash += "&hex=" + hex;
    history.replaceState(null, "", hash);
  }

  function loadFromHash() {
    var hash = location.hash.slice(1);
    if (!hash) return;

    var params = {};
    hash.split("&").forEach(function(part) {
      var eq = part.indexOf("=");
      if (eq > 0) {
        params[part.slice(0, eq)] = decodeURIComponent(part.slice(eq + 1));
      }
    });

    if (params.type) {
      for (var i = 0; i < refbook.types.length; i++) {
        if (refbook.types[i].name === params.type) {
          selectType(i);
          if (params.hex) {
            hexInput.value = params.hex;
            decode();
          }
          return;
        }
      }
    }
  }

  // --- Hex status ---

  function updateHexStatus(hexStr) {
    var statusEl = document.getElementById("hex-status");
    if (!selectedType || hexStr.length === 0) {
      statusEl.textContent = "";
      statusEl.className = "hex-status";
      return;
    }
    var totalWidth = selectedType.total_width;
    var expectedChars = Math.ceil(totalWidth / 4);
    var label = hexStr.length + "/" + expectedChars;

    if (hexStr.length > expectedChars) {
      statusEl.textContent = label;
      statusEl.className = "hex-status overflow";
      statusEl.title = "Overflow: expected " + expectedChars + " hex chars (truncated)";
    } else if (hexStr.length < expectedChars) {
      statusEl.textContent = label;
      statusEl.className = "hex-status padded";
      statusEl.title = "Zero-padded: " + hexStr.length + " of " + expectedChars + " hex chars";
    } else {
      var maxVal = (1n << BigInt(totalWidth)) - 1n;
      var inputVal = BigInt("0x" + hexStr);
      if (inputVal > maxVal) {
        statusEl.textContent = label;
        statusEl.className = "hex-status overflow";
        statusEl.title = "Value exceeds " + totalWidth + "-bit max";
      } else {
        statusEl.textContent = label;
        statusEl.className = "hex-status exact";
        statusEl.title = "Exact fit: " + totalWidth + " bits";
      }
    }
  }

  // --- Decode ---

  function decode() {
    var content = document.getElementById("content");
    if (!selectedType) {
      content.innerHTML = '<div class="empty-state" id="empty-state"></div>';
      renderEmptyState();
      return;
    }

    var hexStr = hexInput.value.replace(/[\s_]/g, "");
    var bits = null;
    var overflow = false;

    if (hexStr.length > 0) {
      if (!/^[0-9a-fA-F]+$/.test(hexStr)) {
        content.innerHTML = '<div class="error-msg">Invalid hex characters</div>';
        updateHexStatus("");
        return;
      }
      var fullBits = hexToBin(hexStr);
      var totalWidth = selectedType.total_width;
      var expectedChars = Math.ceil(totalWidth / 4);
      var maxVal = (1n << BigInt(totalWidth)) - 1n;
      overflow = hexStr.length > expectedChars || BigInt("0x" + hexStr) > maxVal;
      if (fullBits.length > totalWidth) {
        fullBits = fullBits.slice(fullBits.length - totalWidth);
      } else {
        while (fullBits.length < totalWidth) fullBits = "0" + fullBits;
      }
      bits = fullBits;
    }

    updateHexStatus(hexStr);

    var html = '<div class="content-animate">';
    if (bits && overflow) {
      var maxHex = Math.ceil(selectedType.total_width / 4);
      html += '<div class="error-msg" style="margin-bottom:16px;">Warning: input exceeds ' +
        selectedType.total_width + ' bits (max ' + maxHex +
        ' hex chars) -- upper bits truncated</div>';
    }

    if (selectedType.kind === "struct") {
      html += renderRegisterMap(selectedType.fields, selectedType.total_width, bits);
      html += renderStructFields(selectedType.fields, bits, 0);
    } else if (selectedType.kind === "enum") {
      html += renderEnumMembers(selectedType.members, selectedType.total_width, bits);
    }

    html += '</div>';
    content.innerHTML = html;
    updateHash();
    setupHoverInteractions();
  }

  // --- Render: Register Map ---

  function renderRegisterMap(fields, totalWidth, bits) {
    if (!fields || fields.length === 0) return "";

    var ROW_WIDTH = totalWidth <= 64 ? totalWidth : 32;
    var numRows = Math.ceil(totalWidth / ROW_WIDTH);

    var html = '<div class="register-map">';

    for (var row = 0; row < numRows; row++) {
      var rowMsb = totalWidth - 1 - (row * ROW_WIDTH);
      var rowLsb = Math.max(totalWidth - (row + 1) * ROW_WIDTH, 0);
      var rowBits = rowMsb - rowLsb + 1;

      html += '<div class="register-row">';

      // Bit ruler
      html += '<div class="bit-ruler" style="grid-template-columns:repeat(' + rowBits + ',1fr);">';
      for (var b = rowMsb; b >= rowLsb; b--) {
        if (b === rowMsb || b === rowLsb || b % 4 === 0) {
          html += '<span>' + b + '</span>';
        } else {
          html += '<span></span>';
        }
      }
      html += '</div>';

      // Field cells
      html += '<div class="reg-fields" style="grid-template-columns:repeat(' + rowBits + ',1fr);">';

      // Build a map of which field owns each bit in this row
      var segments = computeRowSegments(fields, rowMsb, rowLsb);

      for (var s = 0; s < segments.length; s++) {
        var seg = segments[s];
        var colStart = (rowMsb - seg.msb) + 1;
        var colSpan = seg.msb - seg.lsb + 1;

        if (seg.fieldIndex === -1) {
          // Gap / unused bits
          html += '<div class="reg-field" style="grid-column:' + colStart + '/span ' + colSpan +
            ';background:var(--bg-overlay);color:var(--text-dim);">' +
            '<span class="reg-field-name">-</span></div>';
        } else {
          var f = fields[seg.fieldIndex];
          var color = getFieldColor(seg.fieldIndex);
          var bg = getFieldBg(seg.fieldIndex);
          var fieldBits = extractBits(bits, f.offset, f.width);
          var label = escHtml(f.name);
          var valueStr = "";
          if (fieldBits) valueStr = bitsToHex(fieldBits);

          // For narrow fields (1-2 bits), abbreviate
          if (colSpan <= 2) {
            label = escHtml(f.name.charAt(0));
          } else if (colSpan <= 4) {
            label = escHtml(f.name.length > 3 ? f.name.substring(0, 3) : f.name);
          }

          var tooltip = escAttr(f.name + " [" + (f.offset + f.width - 1) + ":" + f.offset + "]" +
            (valueStr ? " = " + valueStr : ""));

          html += '<div class="reg-field" data-field-index="' + seg.fieldIndex +
            '" style="grid-column:' + colStart + '/span ' + colSpan +
            ';background:' + bg + ';color:' + color + ';" title="' + tooltip + '">' +
            '<span class="reg-field-name">' + label + '</span>';
          if (valueStr && colSpan > 3) {
            html += '<span class="reg-field-value">' + escHtml(valueStr) + '</span>';
          }
          if (colSpan > 5) {
            html += '<span class="reg-field-bits">[' + (f.offset + f.width - 1) + ':' + f.offset + ']</span>';
          }
          html += '</div>';
        }
      }

      html += '</div>'; // reg-fields
      html += '</div>'; // register-row
    }

    html += '</div>'; // register-map
    return html;
  }

  function computeRowSegments(fields, rowMsb, rowLsb) {
    // Build bit ownership array for this row
    var rowBits = rowMsb - rowLsb + 1;
    var owner = new Array(rowBits);
    for (var i = 0; i < rowBits; i++) owner[i] = -1;

    for (var fi = 0; fi < fields.length; fi++) {
      var f = fields[fi];
      var fMsb = f.offset + f.width - 1;
      var fLsb = f.offset;
      // Clip to this row
      var segMsb = Math.min(fMsb, rowMsb);
      var segLsb = Math.max(fLsb, rowLsb);
      if (segMsb < rowLsb || segLsb > rowMsb) continue;
      for (var b = segLsb; b <= segMsb; b++) {
        owner[b - rowLsb] = fi;
      }
    }

    // Convert to segments (MSB-first order)
    var segments = [];
    var pos = rowMsb;
    while (pos >= rowLsb) {
      var fi = owner[pos - rowLsb];
      var segStart = pos;
      while (pos > rowLsb && owner[pos - 1 - rowLsb] === fi) {
        pos--;
      }
      segments.push({ fieldIndex: fi, msb: segStart, lsb: pos });
      pos--;
    }

    return segments;
  }

  // --- Render: Struct fields table ---

  function renderStructFields(fields, bits, depth) {
    if (!fields || fields.length === 0) return "";

    var html = '';
    if (depth === 0) {
      html += '<div class="fields-section"><h3>Fields</h3>';
      html += '<table class="fields-table"><thead><tr>' +
        '<th style="width:20px;"></th><th>Name</th><th>Bits</th><th>Type</th><th>Hex</th><th>Decoded</th>' +
        '</tr></thead><tbody>';
    }

    for (var i = 0; i < fields.length; i++) {
      var f = fields[i];
      var fieldBits = extractBits(bits, f.offset, f.width);
      var hexVal = fieldBits ? bitsToHex(fieldBits) : "-";
      var decoded = "";

      if (f.enum_members && fieldBits) {
        var ename = findEnumName(f.enum_members, fieldBits);
        if (ename) decoded = ename;
        else decoded = "?";
      } else if (fieldBits) {
        var raw = binToBigInt(fieldBits);
        if (f.field_type && f.field_type.signed && fieldBits[0] === "1") {
          raw = raw - (1n << BigInt(f.width));
        }
        decoded = raw.toString();
      }

      var nestClass = depth > 0 ? " field-row-nested" : "";
      var hexCopyable = fieldBits ? ' copyable" data-copy="' + escAttr(hexVal) : '';
      var decodedCopyable = decoded ? ' copyable" data-copy="' + escAttr(decoded) : '';
      var typeName = f.field_type ? escHtml(f.field_type.name) : "";

      html += '<tr class="field-detail-row' + nestClass + '" data-field-index="' + (depth === 0 ? i : "") + '">' +
        '<td><span class="field-color-dot" style="background:' + (depth === 0 ? getFieldColor(i) : 'transparent') + ';"></span></td>' +
        '<td class="field-name-cell">' + escHtml(f.name) + '</td>' +
        '<td class="field-bits-cell">[' + (f.offset + f.width - 1) + ':' + f.offset + ']</td>' +
        '<td class="field-type-name">' + typeName + '</td>' +
        '<td class="field-hex-cell' + hexCopyable + '">' + escHtml(hexVal) + '</td>' +
        '<td class="field-decoded-cell' + decodedCopyable + '">' + escHtml(decoded) + '</td>' +
        '</tr>';

      if (f.inner_fields && f.inner_fields.length > 0) {
        html += renderStructFields(f.inner_fields, bits, depth + 1);
      }
    }

    if (depth === 0) {
      html += '</tbody></table></div>';
    }

    return html;
  }

  // --- Render: Enum members ---

  function renderEnumMembers(members, totalWidth, bits) {
    if (!members || members.length === 0) return "";

    var currentVal = null;
    if (bits) currentVal = binToBigInt(bits);

    var html = '<div class="enum-section"><h3>Members</h3>';
    html += '<table class="enum-table"><thead><tr>' +
      '<th>Name</th><th>Dec</th><th>Hex</th>' +
      '</tr></thead><tbody>';

    for (var i = 0; i < members.length; i++) {
      var m = members[i];
      var hexLen = Math.ceil(totalWidth / 4);
      var mBig = BigInt(m.value);
      var h = mBig.toString(16).toUpperCase();
      while (h.length < hexLen) h = "0" + h;

      var isMatch = currentVal !== null && mBig === currentVal;
      var matchClass = isMatch ? " enum-match" : "";
      var hexStr = "0x" + h;

      html += '<tr class="' + matchClass + '">' +
        '<td class="enum-name copyable" data-copy="' + escAttr(m.name) + '">' + escHtml(m.name) + (isMatch ? " *" : "") + '</td>' +
        '<td class="enum-value copyable" data-copy="' + m.value + '">' + m.value + '</td>' +
        '<td class="enum-hex copyable" data-copy="' + escAttr(hexStr) + '">' + escHtml(hexStr) + '</td>' +
        '</tr>';
    }

    html += '</tbody></table>';

    if (bits) {
      var found = findEnumName(members, bits);
      if (found) {
        html += '<div class="enum-result">Current value: <strong>' +
          escHtml(found) + '</strong> (' + binToBigInt(bits).toString() + ')</div>';
      } else {
        html += '<div class="enum-result no-match">Value ' +
          binToBigInt(bits).toString() + ' does not match any member</div>';
      }
    }

    html += '</div>';
    return html;
  }

  // --- Hover cross-referencing ---

  function setupHoverInteractions() {
    var contentEl = document.getElementById("content");

    contentEl.addEventListener("mouseover", function(e) {
      var regField = e.target.closest(".reg-field");
      if (regField && regField.dataset.fieldIndex !== undefined) {
        highlightField(regField.dataset.fieldIndex);
        return;
      }
      var detailRow = e.target.closest(".field-detail-row");
      if (detailRow && detailRow.dataset.fieldIndex) {
        highlightField(detailRow.dataset.fieldIndex);
        return;
      }
    });

    contentEl.addEventListener("mouseout", function(e) {
      var regField = e.target.closest(".reg-field");
      var detailRow = e.target.closest(".field-detail-row");
      if (regField || detailRow) {
        clearFieldHighlights();
      }
    });
  }

  function highlightField(fieldIndex) {
    clearFieldHighlights();
    // Highlight register map fields
    var regFields = document.querySelectorAll('.reg-field[data-field-index="' + fieldIndex + '"]');
    for (var i = 0; i < regFields.length; i++) {
      regFields[i].classList.add("hovered");
    }
    // Highlight detail table rows
    var detailRows = document.querySelectorAll('.field-detail-row[data-field-index="' + fieldIndex + '"]');
    for (var i = 0; i < detailRows.length; i++) {
      detailRows[i].classList.add("field-highlighted");
    }
  }

  function clearFieldHighlights() {
    var hovered = document.querySelectorAll(".hovered");
    for (var i = 0; i < hovered.length; i++) hovered[i].classList.remove("hovered");
    var highlighted = document.querySelectorAll(".field-highlighted");
    for (var i = 0; i < highlighted.length; i++) highlighted[i].classList.remove("field-highlighted");
  }

  // --- Copy to clipboard ---

  document.getElementById("content").addEventListener("click", function(e) {
    var el = e.target.closest(".copyable");
    if (!el || !el.dataset.copy) return;

    navigator.clipboard.writeText(el.dataset.copy).then(function() {
      el.classList.add("copied");
      setTimeout(function() { el.classList.remove("copied"); }, 600);
    });
  });

  // --- Init ---

  loadFromHash();

})();
</script>

</body>
</html>
